import SimpleITK as sitk
import numpy, pywt, logging
from itertools import chain

def getHistogram(binwidth, parameterValues):
  # Start binning form the first value lesser than or equal to the minimum value and evenly dividable by binwidth
  lowBound = min(parameterValues) - (min(parameterValues) % binwidth)
  # Add + binwidth to ensure the maximum value is included in the range generated by numpu.arange
  highBound = max(parameterValues) + binwidth

  binedges = numpy.arange(lowBound, highBound, binwidth)

  binedges[-1] += 1 # ensures that max(self.targertVoxelArray) is binned to upper bin by numpy.digitize

  return numpy.histogram(parameterValues, bins=binedges)

def binImage(binwidth, parameterValues, parameterMatrix = None, parameterMatrixCoordinates = None):
  histogram = getHistogram(binwidth, parameterValues)
  parameterMatrix[parameterMatrixCoordinates] = numpy.digitize(parameterValues, histogram[1])

  return parameterMatrix, histogram

def cropTumorMaskToCube(imageNode, maskNode, padDistance= 0):
  """
  Crops image and label to the labelled region, resulting in a cuboid shape equal to the ijk boundaries of the label.
  Optionally increases resultant shape in all dimensions with unit length equal to padDistance.
  All voxels outside delineation also retain original image intensity values.

  This is achieved by resampling the image and mask using the same pixelSpacing, but with resampling grid
  adapted to match the cropped volume. sitkNearestNeighbour is used as interpolator for both image and mask resampling.

  'imageNode' and 'maskNode' are SimpleITK Objects.
  """

  if imageNode == None or maskNode == None:
    return None

  #Determine bounds of cropped volume
  labelNodeArray = sitk.GetArrayFromImage(maskNode)
  targetVoxelsCoordinates = numpy.where(labelNodeArray != 0)
  ijkMinBounds = numpy.min(targetVoxelsCoordinates, 1)
  ijkMaxBounds = numpy.max(targetVoxelsCoordinates, 1)

  #size of the cropped tumor volume
  newSize = numpy.array((ijkMaxBounds-ijkMinBounds + 1)[::-1], dtype= 'int32') + padDistance

  newOriginIndex = numpy.array(ijkMinBounds[::-1], dtype= 'int32') - numpy.floor_divide(padDistance, 2)
  newOrigin = imageNode.TransformIndexToPhysicalPoint(newOriginIndex)

  rif = sitk.ResampleImageFilter()

  rif.SetOutputSpacing(imageNode.GetSpacing())
  rif.SetOutputDirection(imageNode.GetDirection())
  rif.SetSize(newSize)
  rif.SetOutputOrigin(newOrigin)
  rif.SetInterpolator(sitk.sitkNearestNeighbor)

  rif.SetOutputPixelType(imageNode.GetPixelID())
  croppedImageNode = rif.Execute(imageNode)

  rif.SetOutputPixelType(imageNode.GetPixelID())
  croppedMaskNode = rif.Execute(maskNode)

  return croppedImageNode,croppedMaskNode

def getMatrixCoordinates(imageNodeArray, labelNodeArray):
    """
    Returns a matrix similar to imageNodeArray, but with voxels outside delineation set to 0.
    Additionally, returns the indices to the voxels inside the delineation.
    """

    matrixCoordinates =  numpy.where(labelNodeArray != 0)

    # Only set voxels inside delineation to intensity value,
    # voxels outside delineation retain padding value (= 0)
    matrix = numpy.zeros( imageNodeArray.shape)
    matrix[matrixCoordinates] = imageNodeArray[matrixCoordinates]

    return matrix, matrixCoordinates

def resampleImage(imageNode, maskNode, resampledPixelSpacing, interpolator=sitk.sitkBSpline):
  """
  Resamples image or label to the specified pixel spacing (The default interpolator is Bspline)

  'imageNode' is a SimpleITK Object, and 'resampledPixelSpacing' is the output pixel spacing.
  Enumerator references for interpolator:
  0 - sitkNearestNeighbor
  1 - sitkLinear
  2 - sitkBSpline
  3 - sitkGaussian
  """

  if imageNode == None or maskNode == None:
    return None

  oldSpacing = numpy.array(imageNode.GetSpacing())

  # If current spacing is equal to resampledPixelSpacing, no interpolation is needed
  if numpy.array_equal(oldSpacing, resampledPixelSpacing):
    return imageNode, maskNode

  oldImagePixelType = imageNode.GetPixelID()
  oldMaskPixelType = imageNode.GetPixelID()

  imageDirection = numpy.array(imageNode.GetDirection())

  oldOrigin = numpy.array(imageNode.GetOrigin())
  oldSize = numpy.array(imageNode.GetSize())

  # Recalculate the new size. Round up to prevent data loss.
  newSize = numpy.array(numpy.ceil(oldSize * oldSpacing / resampledPixelSpacing),dtype='int')
  # Origin is located in center of first voxel, e.g. 1/2 of the spacing
  # from Corner, which corresponds to 0 in the original Index coordinate space.
  # The new spacing will be in 0 the new Index coordinate space. Here we use continuous
  # index to calculate where the new 0 of the new Index coordinate space is in terms
  # of the original spacing, and then use the ITK functionality to bring the contiuous index
  # into the physical space (mm)
  newOriginIndex = numpy.array(.5*(resampledPixelSpacing-oldSpacing)/oldSpacing)
  newOrigin = imageNode.TransformContinuousIndexToPhysicalPoint(newOriginIndex)

  rif = sitk.ResampleImageFilter()

  rif.SetOutputSpacing(resampledPixelSpacing)
  rif.SetOutputDirection(imageDirection)
  rif.SetSize(newSize)
  rif.SetOutputOrigin(newOrigin)

  rif.SetOutputPixelType(oldImagePixelType)
  rif.SetInterpolator(interpolator)
  resampledImageNode = rif.Execute(imageNode)

  rif.SetOutputPixelType(oldMaskPixelType)
  rif.SetInterpolator(sitk.sitkNearestNeighbor)
  resampledMaskNode = rif.Execute(maskNode)

  return resampledImageNode,resampledMaskNode

#
# Use the SimpleITK LaplacianRecursiveGaussianImageFilter
# on the input image with the given sigmaValue and return
# the filtered image.
# If sigmaValue is not greater than zero, return the input image.
#
def applyLoG(inputImage, sigmaValue=0.5):
  if sigmaValue > 0.0:
    lrgif = sitk.LaplacianRecursiveGaussianImageFilter()
    lrgif.SetNormalizeAcrossScale(True)
    lrgif.SetSigma(sigmaValue)
    return lrgif.Execute(inputImage)
  else:
    logging.info('applyLoG: sigma must be greater than 0.0: %g', sigmaValue)
    return inputImage

def applyThreshold(inputImage, lowerThreshold, upperThreshold, insideValue=None, outsideValue=0):
  # this mode is useful to generate the mask of thresholded voxels
  if insideValue:
    tif = sitk.BinaryThresholdImageFilter()
    tif.SetInsideValue(insideValue)
    tif.SetLowerThreshold(lowerThreshold)
    tif.SetUpperThreshold(upperThreshold)
  else:
    tif = sitk.ThresholdImageFilter()
    tif.SetLower(lowerThreshold)
    tif.SetUpper(upperThreshold)
  tif.SetOutsideValue(outsideValue)
  return tif.Execute(inputImage)

def swt3(inputImage, wavelet="coif1", level=1, start_level=0):
  matrix = sitk.GetArrayFromImage(inputImage)
  matrix = numpy.asarray(matrix)
  data = matrix.copy()
  if data.ndim != 3:
    raise ValueError("Expected 3D data array")

  original_shape = matrix.shape
  adjusted_shape = tuple([dim+1 if dim % 2 != 0 else dim for dim in original_shape])
  data = numpy.resize(data, adjusted_shape)

  if not isinstance(wavelet, pywt.Wavelet):
    wavelet = pywt.Wavelet(wavelet)

  for i in range(0, start_level):
    H, L = decompose_i(data, wavelet)
    LH, LL = decompose_j(L, wavelet)
    LLH, LLL = decompose_k(LL, wavelet)

    data = LLL.copy()

  ret = []
  for i in range(start_level, start_level + level):
    H, L = decompose_i(data, wavelet)

    HH, HL = decompose_j(H, wavelet)
    LH, LL = decompose_j(L, wavelet)

    HHH, HHL = decompose_k(HH, wavelet)
    HLH, HLL = decompose_k(HL, wavelet)
    LHH, LHL = decompose_k(LH, wavelet)
    LLH, LLL = decompose_k(LL, wavelet)

    data = LLL.copy()

    dec = {'HHH': HHH,
           'HHL': HHL,
           'HLH': HLH,
           'HLL': HLL,
           'LHH': LHH,
           'LHL': LHL,
           'LLH': LLH}
    for decName, decImage in dec.iteritems():
      decTemp = decImage.copy()
      decTemp= numpy.resize(decTemp, original_shape)
      sitkImage = sitk.GetImageFromArray(decTemp)
      sitkImage.CopyInformation(inputImage)
      dec[decName] = sitkImage

    ret.append(dec)

  data= numpy.resize(data, original_shape)
  approximation = sitk.GetImageFromArray(data)
  approximation.CopyInformation(inputImage)

  return approximation, ret

def decompose_i(data, wavelet):
  #process in i:
  H, L = [], []
  i_arrays = chain.from_iterable(numpy.transpose(data,(0,1,2)))
  for i_array in i_arrays:
    cA, cD = pywt.swt(i_array, wavelet, level=1, start_level=0)[0]
    H.append(cD)
    L.append(cA)
  H = numpy.hstack(H).reshape(data.shape)
  L = numpy.hstack(L).reshape(data.shape)
  return H, L

def decompose_j(data, wavelet):
  #process in j:
  H, L = [], []
  j_arrays = chain.from_iterable(numpy.transpose(data,(0,1,2)))
  for j_array in j_arrays:
    cA, cD = pywt.swt(j_array, wavelet, level=1, start_level=0)[0]
    H.append(cD)
    L.append(cA)
  H = numpy.asarray( [slice.T for slice in numpy.split(numpy.vstack(H), data.shape[0])] )
  L = numpy.asarray( [slice.T for slice in numpy.split(numpy.vstack(L), data.shape[0])] )
  return H, L

def decompose_k(data, wavelet):
  #process in k:
  H, L = [], []
  k_arrays = chain.from_iterable(numpy.transpose(data,(1,2,0)))
  for k_array in k_arrays:
    cA, cD = pywt.swt(k_array, wavelet, level=1, start_level=0)[0]
    H.append(cD)
    L.append(cA)
  H = numpy.dstack(H).reshape(data.shape)
  L = numpy.dstack(L).reshape(data.shape)
  return H, L
